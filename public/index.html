<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8" />
  <title>Matcap â€“ True Square Shader Space</title>
  <style>
    html, body {
      margin: 0; padding: 0;
      width: 100%; height: 100%;
      background: #000; overflow: hidden;
    }
  </style>
</head>

<body>
<script type="module">
import * as THREE from "https://cdn.jsdelivr.net/npm/three@0.166.0/build/three.module.js";

const renderer = new THREE.WebGLRenderer({ antialias: true });
document.body.appendChild(renderer.domElement);

const scene = new THREE.Scene();
const camera = new THREE.OrthographicCamera(-1, 1, 1, -1, 0, 1);

// geometry
const geo = new THREE.PlaneGeometry(2, 2);

// Get preset configuration from server or use defaults
const preset = window.SHADER_PRESET || {
  normalMap: "paragraph_normal.png",
  displacementMap: "paragraph.png",
  zoomLevel: 0.8,
  dispStrength: 0.3,
  matcap: "matcap2.jpeg"
};

// textures
const TL = new THREE.TextureLoader();
const matcap = TL.load(preset.matcap);
const normalMap = TL.load(preset.normalMap);
const dispMap = TL.load(preset.displacementMap);

normalMap.wrapS = normalMap.wrapT = THREE.ClampToEdgeWrapping;
dispMap.wrapS = dispMap.wrapT = THREE.ClampToEdgeWrapping;

// --------------------------
// MATERIAL FIRST
// --------------------------
const material = new THREE.ShaderMaterial({
  uniforms: {
    uMatcap: { value: matcap },
    uNormalMap: { value: normalMap },
    uDisplacementMap: { value: dispMap },
    uTime: { value: 0 },
    uRotation: { value: 0 },
    uDispStrength: { value: preset.dispStrength },
    uZoomLevel: { value: preset.zoomLevel },
    uResolution: { value: new THREE.Vector2(1, 1) }
  },
  vertexShader: `
    varying vec2 vUv;
    void main() {
      vUv = uv;
      gl_Position = vec4(position, 1.0);
    }
  `,
  fragmentShader: `
    precision mediump float;

    uniform sampler2D uMatcap;
    uniform sampler2D uNormalMap;
    uniform sampler2D uDisplacementMap;

    uniform vec2 uResolution;
    uniform float uRotation;
    uniform float uTime;
    uniform float uDispStrength;
    uniform float uZoomLevel;

    varying vec2 vUv;

    void main() {

      // keep shader space square
      float aspect = uResolution.x / uResolution.y;
      vec2 texUv = vUv;

      if (aspect > 1.0) {
        // wide screen
        texUv.x = (texUv.x - 0.5) * aspect + 0.5;
      } else {
        // tall screen
        texUv.y = (texUv.y - 0.5) / aspect + 0.5;
      }

      texUv = (texUv - 0.5) * uZoomLevel + 0.5;

      // normal
      vec3 tangentNormal = texture2D(uNormalMap, texUv).xyz * 2.0 - 1.0;

      float n1 = sin(texUv.x * 2.0 + uTime * 0.15);
      float n2 = cos(texUv.y * 1.3 + uTime * 0.17);
      tangentNormal = normalize(tangentNormal + vec3(n1, n2, 0.0) * 100.0);

      vec3 viewNormal = normalize(vec3(tangentNormal.xy, tangentNormal.z));

      vec2 mc = viewNormal.xy;
      float s = sin(uRotation);
      float c = cos(uRotation);
      mc = mat2(c, -s, s, c) * mc;

      float disp = texture2D(uDisplacementMap, texUv).r;
      mc += vec2(cos(disp * 6.28318), sin(disp * 6.28318)) * uDispStrength;

      mc = mc * 0.5 + 0.5;
      vec3 matcapColor = texture2D(uMatcap, mc).rgb;
      // Brighten the reflection
      matcapColor = matcapColor * 1.8; // Increase brightness
      gl_FragColor = vec4(matcapColor, 1.0) * disp;
    }
  `
});

// --------------------------
// THEN CREATE MESH
// --------------------------
const quad = new THREE.Mesh(geo, material);
scene.add(quad);

// --------------------------
// THEN RESIZE()
// --------------------------
function resize() {
  renderer.setSize(window.innerWidth, window.innerHeight);
  material.uniforms.uResolution.value.set(window.innerWidth, window.innerHeight);
}
resize();
window.addEventListener("resize", resize);

// --------------------------
// RENDER LOOP
// --------------------------
renderer.setAnimationLoop((t) => {
  material.uniforms.uTime.value = t * 0.001;
  material.uniforms.uRotation.value = t * 0.0005;
  renderer.render(scene, camera);
});
</script>
</body>
</html>
